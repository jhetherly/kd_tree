namespace Analysis {

template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
kd_tree<Key, T, Compare, Equate, Alloc>::kd_tree (Iterator begin, Iterator end,
                                                  const size_t &dim) :
  kd_tree(begin, end, dim, m_defaultCR)
{
}


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator, class CR>
kd_tree<Key, T, Compare, Equate, Alloc>::kd_tree (Iterator begin, Iterator end,
                                                  const size_t &dim, const CR &collisionResolver) :
  m_dim(dim)
{
  auto length = std::distance(begin, end);

  // iteratively construct tree (doesn't blow the stack for large trees)
  if (length == 0) return;

  std::forward_list < std::pair < Iterator, Iterator >> ranges = { { begin, end } };
  std::forward_list<kd_tree_internal::kd_node<Key, T, Alloc>*> nodes = { new kd_tree_internal::kd_node<Key, T, Alloc>() };
  std::forward_list<unsigned long long> depths = { 0 };
  std::pair < kd_tree_internal::kd_node<Key, T, Alloc>*, unsigned long long > last_single_parent;

  this->m_root = nodes.front();

  while (!ranges.empty()) {
    auto &range       = ranges.front();
    auto  node        = nodes.front();
    auto  depth       = depths.front();
    auto  coord_index = depth % m_dim;
    auto  median      = this->computeMedian(range, coord_index);
    node->m_median    = median;
    auto  new_ranges    = this->splitRange(range, coord_index, *median);
    auto &left_range    = new_ranges.first,
    &right_range        = new_ranges.second;
    auto left_distance  = std::distance(left_range.first, left_range.second),
         right_distance = std::distance(right_range.first, right_range.second);

    ranges.pop_front();
    nodes.pop_front();
    depths.pop_front();

    // check for duplicates
    if (last_single_parent.first != nullptr && depth - last_single_parent.second > dim + 1) {
      auto  test_ranges        = this->specialSplitRange(right_range, (*(right_range.first)).first);
      auto &left_test_range    = test_ranges.first,
      &right_test_range        = test_ranges.second;
      auto right_test_distance = std::distance(right_test_range.first, right_test_range.second);

      if (right_test_distance > 0) { // not all elements are the same
        auto last_same = std::prev(left_test_range.second);
        // TODO:
        last_same->second = collisionResolver(left_test_range.first, left_test_range.second);
        delete last_single_parent.first->m_rightChild;
        nodes.push_front(last_single_parent.first);
        ranges.push_front({last_same, right_test_range.second});
        depths.push_front(last_single_parent.second);
        last_single_parent.first = nullptr;
        last_single_parent.second = 0;
        continue;
      }
      else { // all elements are the same
        delete last_single_parent.first->m_rightChild;
        // TODO:
        stored_type new_stored_value = collisionResolver(right_range.first, right_range.second);
        value_type new_value = {right_range.first->first, new_stored_value};
        // TODO: use allocator
        node->m_rightChild = new kd_tree_internal::kd_leaf<Key, T, Alloc>(new_value);
        m_values.emplace_front(
          static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(node->m_rightChild)->GetPair()
          );
        last_single_parent.first = nullptr;
        last_single_parent.second = 0;
        continue;
      }
    }

    // no duplicates
    if (right_distance > 0) {
      // TODO: use allocator
      if (right_distance == 1)
        node->m_rightChild = new kd_tree_internal::kd_leaf<Key, T, Alloc>(value_type(*right_range.first));
      else {
        nodes.push_front(new kd_tree_internal::kd_node<Key, T, Alloc>());
        node->m_rightChild = nodes.front();
        ranges.push_front(right_range);
        depths.push_front(depth + 1);
      }
    }

    if (left_distance > 0) {
      // TODO: use allocator
      if (left_distance == 1)
        node->m_leftChild = new kd_tree_internal::kd_leaf<Key, T, Alloc>(value_type(*left_range.first));
      else {
        nodes.push_front(new kd_tree_internal::kd_node<Key, T, Alloc>());
        node->m_leftChild = nodes.front();
        ranges.push_front(left_range);
        depths.push_front(depth + 1);
      }
    }
    if (left_distance == 1) {
      m_values.emplace_front(
        static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(node->m_leftChild)->GetPair()
        );
    }
    if (right_distance == 1) {
      m_values.emplace_front(
        static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(node->m_rightChild)->GetPair()
        );
    }
    // reset condition for last_single_parent
    if ((left_distance == 0 && right_distance == 1) ||
        (left_distance == 1 && right_distance == 1)) {
      last_single_parent.first = nullptr;
      last_single_parent.second = 0;
    }
    // new last_single_parent
    // single parents only have "right" children
    if ((left_distance == 0 && right_distance > 1)) {
      if (last_single_parent.first == nullptr) {
        last_single_parent.first = node;
        last_single_parent.second = depth;
      }
    }
  }
}


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
const typename Key::value_type*
kd_tree<Key, T, Compare, Equate, Alloc>::computeMedian (std::pair<Iterator, Iterator> &range,
                                                const unsigned long long &coord_index)
{
  const auto &range_begin = range.first,
  &range_end              = range.second;
  auto   range_distance   = std::distance(range_begin, range_end);
  const subkey_type *median = nullptr;
  auto   pred = [&coord_index, this](const typename std::decay<decltype(*range_begin)>::type &l,
                                     const typename std::decay<decltype(*range_begin)>::type &r)
                {
                  // works with containers (for keys) other than vectors
                  auto li = /*static_cast<const value_type&>(*/l/*)*/.first.begin(),
                       ri = /*static_cast<const value_type&>(*/r/*)*/.first.begin();
                  std::advance(li, coord_index);
                  std::advance(ri, coord_index);
                  return this->m_comp(*li, *ri);
                };

  {
    auto mid = range.first;
    std::advance(mid, range_distance / 2);

    std::nth_element(range_begin, mid, range_end, pred);

    auto mi = /*static_cast<const value_type>*/(*mid).first.begin();
    std::advance(mi, coord_index);

    median = &(*mi);
  }

  return median;
} // computeMedian


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
std::pair < std::pair<Iterator, Iterator>,
std::pair < Iterator, Iterator >>
kd_tree<Key, T, Compare, Equate, Alloc>::splitRange(std::pair<Iterator, Iterator>&range,
                                            const unsigned long long &coord_index,
                                            const typename Key::value_type &median)
{
  std::pair < std::pair<Iterator, Iterator>,
  std::pair < Iterator, Iterator >> result;
  auto &left_result = result.first,
  &right_result     = result.second;
  auto pred         = [&coord_index, &median, this](const typename std::decay<decltype(*range.first)>::type &e)
                      {
                        auto ei = /*static_cast<const value_type&>(*/e/*)*/.first.begin();
                        std::advance(ei, coord_index);
                        return this->m_comp(*ei, median);
                      };

  auto bound = std::partition(range.first, range.second, pred);

  left_result  = { range.first, bound };
  right_result = { bound, range.second };

  return result;
}


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
std::pair < std::pair<Iterator, Iterator>,
std::pair < Iterator, Iterator >>
kd_tree<Key, T, Compare, Equate, Alloc>::specialSplitRange(std::pair<Iterator, Iterator>&range,
                                                           const key_type &ref)
{
  std::pair < std::pair<Iterator, Iterator>,
  std::pair < Iterator, Iterator >> result;
  auto &left_result = result.first,
  &right_result     = result.second;
  auto pred         = [&ref, this](const typename std::decay<decltype(*range.first)>::type &e)
                      {
                        auto ei = /*static_cast<const value_type&>(*/e/*)*/.first.begin(),
                             ri = /*static_cast<const value_type&>(*/ref/*)*/.begin();
                        bool are_same = true;
                        while (ei != e.first.end() && ri != ref.end() && are_same) {
                          are_same &= this->m_equate(*ei, *ri);
                          ei = std::next(ei);
                          ri = std::next(ri);
                        }
                        return are_same;
                      };

  auto bound = std::partition(range.first, range.second, pred);

  left_result  = { range.first, bound };
  right_result = { bound, range.second };

  return result;
}


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Container>
auto
kd_tree<Key, T, Compare, Equate, Alloc>::operator[](const Container &con) const
  ->std::forward_list < std::reference_wrapper < const value_type >>
{
  using std::get;

  std::forward_list < std::reference_wrapper < const value_type >> result;

  std::forward_list<kd_tree_internal::kd_node_base*> ns { this->m_root };
  std::forward_list<unsigned long long> depths { 0 };

  while (!ns.empty()) {
    auto n           = ns.front();
    auto depth       = depths.front();
    auto coord_index = depth % m_dim;
    auto it          = con.begin();
    std::advance(it, coord_index);
    auto min = get<0>(*it),
         max = get<1>(*it);

    ns.pop_front();
    depths.pop_front();

    if (n->isLeaf()) {
      auto leaf = static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(n);
      auto add  = this->CheckKey(con, leaf->GetKey());

      if (add) result.emplace_front(leaf->GetPair());
      // if (add) result.emplace_back(leaf->GetPair());
    }
    else {
      auto node    = static_cast<kd_tree_internal::kd_node<Key, T, Alloc>*>(n);
      const auto &median  = node->GetMedian();
      auto left_n  = node->GetLeftChild(),
           right_n = node->GetRightChild();

      if ((m_comp(min, median) || m_equate(min, median)) &&
          !m_comp(max, median)) { // both
        if (right_n != nullptr) {
          ns.push_front(right_n);
          depths.push_front(depth + 1);
        }

        if (left_n != nullptr) {
          ns.push_front(left_n);
          depths.push_front(depth + 1);
        }
      }
      else if (m_comp(median, min)) { // right
        if (right_n != nullptr) {
          ns.push_front(right_n);
          depths.push_front(depth + 1);
        }
      }
      else if (m_comp(max, median)) { // left
        if (left_n != nullptr) {
          ns.push_front(left_n);
          depths.push_front(depth + 1);
        }
      }
    }
  }

  return result;
} // []

template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Container>
bool
kd_tree<Key, T, Compare, Equate, Alloc>::CheckKey (const Container &con, const Key &key) const
{
  auto ci = con.begin();
  auto ki = key.begin();
  bool result { true };

  do {
    auto min = ci->first,
         max = ci->second;
    result &= ((m_comp(min, *ki) || m_equate(min, *ki)) &&
               (m_comp(*ki, max) || m_equate(*ki, max)));
    ci      = std::next(ci);
    ki      = std::next(ki);
  } while (ci != con.end() && ki != key.end() && result);

  return result;
} // CheckKey

}
