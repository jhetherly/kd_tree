namespace Analysis {
template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
kd_tree<Key, T, Compare, Equate, Alloc>::kd_tree (Iterator begin, Iterator end, const size_t &dim) :
  m_dim(dim)
{
  auto length = std::distance(begin, end);

  // iteratively construct tree (doesn't blow the stack for large trees)
  if (length == 0) return;

  std::forward_list < std::pair < Iterator, Iterator >> ranges { { begin, end } };
  std::forward_list<kd_tree_internal::kd_node<Key, T>*> nodes { new kd_tree_internal::kd_node<Key, T>() };
  std::forward_list<unsigned long long> depths { 0 };

  this->m_root = nodes.front();

  while (!ranges.empty()) {
    auto &range       = ranges.front();
    auto  node        = nodes.front();
    auto  depth       = depths.front();
    auto  coord_index = depth % m_dim;
    auto  median      = this->computeMedian(range, coord_index);
    node->m_median    = median;
    auto  new_ranges    = this->splitRange(range, coord_index, median);
    auto &left_range    = new_ranges.first,
    &right_range        = new_ranges.second;
    auto left_distance  = std::distance(left_range.first, left_range.second),
         right_distance = std::distance(right_range.first, right_range.second);

    ranges.pop_front();
    nodes.pop_front();
    depths.pop_front();

    if (right_distance > 0) {
      // TODO: use allocator
      if (right_distance == 1)
        node->m_rightChild = new kd_tree_internal::kd_leaf<Key, T, Alloc>(value_type(*right_range.first));
      else {
        nodes.push_front(new kd_tree_internal::kd_node<Key, T>());
        node->m_rightChild = nodes.front();
        ranges.push_front(right_range);
        depths.push_front(depth + 1);
      }
    }

    if (left_distance > 0) {
      // TODO: use allocator
      if (left_distance == 1)
        node->m_leftChild = new kd_tree_internal::kd_leaf<Key, T, Alloc>(value_type(*left_range.first));
      else {
        nodes.push_front(new kd_tree_internal::kd_node<Key, T>());
        node->m_leftChild = nodes.front();
        ranges.push_front(left_range);
        depths.push_front(depth + 1);
      }
    }
    if (left_distance == 1) {
      m_values.emplace_front(
        static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(node->m_leftChild)->GetPair()
        );
    }
    if (right_distance == 1) {
      m_values.emplace_front(
        static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(node->m_rightChild)->GetPair()
        );
    }
  }
}


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
typename Key::value_type
kd_tree<Key, T, Compare, Equate, Alloc>::computeMedian (std::pair<Iterator, Iterator> &range,
                                                const unsigned long long &coord_index)
{
  const auto &range_begin = range.first,
  &range_end              = range.second;
  auto   range_distance   = std::distance(range_begin, range_end);
  subkey_type median;
  auto   pred = [&coord_index, this](const decltype(*range_begin) &l, const decltype(*range_begin) &r)
                {
                  // works with containers (for keys) other than vectors
                  auto li = /*static_cast<const value_type&>(*/l/*)*/.first.begin(),
                       ri = /*static_cast<const value_type&>(*/r/*)*/.first.begin();
                  std::advance(li, coord_index);
                  std::advance(ri, coord_index);
                  return this->m_comp(*li, *ri);
                };

  {
    auto mid = range.first;
    std::advance(mid, range_distance / 2);

    std::nth_element(range_begin, mid, range_end, pred);

    auto mi = /*static_cast<const value_type>*/(*mid).first.begin();
    std::advance(mi, coord_index);

    median = *mi;
  }

  return median;
} // computeMedian


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Iterator>
std::pair < std::pair<Iterator, Iterator>,
std::pair < Iterator, Iterator >>
kd_tree<Key, T, Compare, Equate, Alloc>::splitRange(std::pair<Iterator, Iterator>&range,
                                            const unsigned long long &coord_index,
                                            const typename Key::value_type &median)
{
  std::pair < std::pair<Iterator, Iterator>,
  std::pair < Iterator, Iterator >> result;
  auto &left_result = result.first,
  &right_result     = result.second;
  auto pred         = [&coord_index, &median, this](const decltype(*range.first) &e)
                      {
                        auto ei = /*static_cast<const value_type&>(*/e/*)*/.first.begin();
                        std::advance(ei, coord_index);
                        return this->m_comp(*ei, median);
                      };

  auto bound = std::partition(range.first, range.second, pred);

  left_result  = { range.first, bound };
  right_result = { bound, range.second };

  return result;
}


template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Container>
auto
kd_tree<Key, T, Compare, Equate, Alloc>::operator[](const Container &con) const
  ->std::forward_list < std::reference_wrapper < const value_type >>
{
  std::forward_list < std::reference_wrapper < const value_type >> result;

  std::forward_list<kd_tree_internal::kd_node_base*> ns { this->m_root };
  std::forward_list<unsigned long long> depths { 0 };

  while (!ns.empty()) {
    auto n           = ns.front();
    auto depth       = depths.front();
    auto coord_index = depth % m_dim;
    auto it          = con.begin();
    std::advance(it, coord_index);
    auto min = it->first,
         max = it->second;

    ns.pop_front();
    depths.pop_front();

    if (n->isLeaf()) {
      auto leaf = static_cast<kd_tree_internal::kd_leaf<Key, T, Alloc>*>(n);
      auto add  = this->CheckKey(con, leaf->GetKey());

      if (add) result.emplace_front(leaf->GetPair());
      // if (add) result.emplace_back(leaf->GetPair());
    }
    else {
      auto node    = static_cast<kd_tree_internal::kd_node<Key, T>*>(n);
      auto median  = node->GetMedian();
      auto left_n  = node->GetLeftChild(),
           right_n = node->GetRightChild();

      if ((m_comp(min, median) || m_equate(min, median)) &&
          !m_comp(max, median)) { // both
        if (right_n != nullptr) {
          ns.push_front(right_n);
          depths.push_front(depth + 1);
        }

        if (left_n != nullptr) {
          ns.push_front(left_n);
          depths.push_front(depth + 1);
        }
      }
      else if (m_comp(median, min)) { // right
        if (right_n != nullptr) {
          ns.push_front(right_n);
          depths.push_front(depth + 1);
        }
      }
      else if (m_comp(max, median)) { // left
        if (left_n != nullptr) {
          ns.push_front(left_n);
          depths.push_front(depth + 1);
        }
      }
    }
  }

  return result;
} // []

template<class Key, class T,
         class Compare, class Equate, class Alloc>
template<class Container>
bool
kd_tree<Key, T, Compare, Equate, Alloc>::CheckKey (const Container &con, const Key &key) const
{
  auto ci = con.begin();
  auto ki = key.begin();
  bool result { true };

  do {
    auto min = ci->first,
         max = ci->second;
    result &= ((m_comp(min, *ki) || m_equate(min, *ki)) &&
               (m_comp(*ki, max) || m_equate(*ki, max)));
    ci      = std::next(ci);
    ki      = std::next(ki);
  } while (ci != con.end() && ki != key.end() && result);

  return result;
} // CheckKey
}
